import { GroupType } from './enums/group-type.enum';
import { LeaderboardType } from './enums/leaderboard-type.enum';
import { Platform } from './enums/platform.enum';
import { TimeWindow } from './enums/time-window.enum';
import { IFortniteClientCredentials } from './interfaces/fortnite-client-credentials.interface';
import { IFortniteClientOptions } from './interfaces/fortnite-client-options.interface';
import { Leaderboard } from './models/leaderboard/leaderboard';
import { Lookup } from './models/lookup/lookup';
import { Welcome } from './models/news/welcome';
import { PlayerStats } from './models/stats/player-stats';
import { Status } from './models/status/status';
import { Store } from './models/store/store';
/**
 * Fortnite client
 */
export declare class FortniteClient {
    private apiRequest;
    private credentials;
    private launcherAccessToken;
    private clientAccessToken;
    /**
     * Creates a new fortnite client instance.
     * @param credentials The account's credentials which shall be used for the REST requests.
     * @param options Library specific options (such as a response timeout until it throws an exception).
     */
    constructor(credentials: IFortniteClientCredentials, options?: IFortniteClientOptions);
    static CHECK_STATUS(): Promise<Status>;
    static GET_GAME_NEWS(countryCode?: string): Promise<Welcome>;
    login(): Promise<void>;
    getBattleRoyaleStatsById(userId: string, timeWindow?: TimeWindow): Promise<PlayerStats>;
    getLeaderboards(leaderboardType: LeaderboardType, platform: Platform, groupType: GroupType, timeWindow?: TimeWindow, limit?: number): Promise<Leaderboard>;
    getStore(locale?: string): Promise<Store>;
    /**
     * Checks if a player with the given name exists. If it exists, it will return the playerId
     * @param username Full text playername (e. g. 'NinjasHyper')
     */
    lookup(username: string): Promise<Lookup>;
    /**
     * Updates the default auth header for client requests and sets the property
     * @param token The new client access token
     */
    private updateClientAccessToken(token);
    private onTokenExpired(token, secretKey);
    /**
     * Required to send right after successful login, when logging in frequently
     */
    private killOtherSessions();
    private refreshToken(token, secretKey);
    private requestOAuthToken(authCode);
    private requestOAuthExchange(accessToken);
    /**
     * Request Login Token after (logging in with password)
     */
    private requestAccessToken();
}
